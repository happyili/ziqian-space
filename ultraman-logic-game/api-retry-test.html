<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>APIé‡è¯•æœºåˆ¶æµ‹è¯•</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #f0f0f0; }
        .test-btn { background: #007cba; color: white; border: none; padding: 15px 25px; margin: 10px; border-radius: 8px; cursor: pointer; font-size: 1rem; }
        .test-btn:hover { background: #005a8b; }
        .test-btn:disabled { background: #ccc; cursor: not-allowed; }
        .result { background: white; padding: 15px; margin: 10px 0; border-radius: 8px; border-left: 4px solid #007cba; }
        .error { border-left-color: #e74c3c; background: #fdf2f2; color: #721c24; }
        .success { border-left-color: #27ae60; background: #f2fdf2; color: #155724; }
        .warning { border-left-color: #f39c12; background: #fef9e7; color: #856404; }
        pre { background: #f8f9fa; padding: 10px; border-radius: 5px; overflow-x: auto; font-size: 0.9rem; white-space: pre-wrap; }
        .status { font-weight: bold; margin-bottom: 10px; }
        .progress { background: #e9ecef; border-radius: 10px; overflow: hidden; margin: 10px 0; }
        .progress-bar { background: #007cba; height: 20px; transition: width 0.3s ease; }
    </style>
</head>
<body>
    <h1>ğŸ”„ APIé‡è¯•æœºåˆ¶æµ‹è¯•</h1>
    
    <div class="result">
        <h3>ğŸ› ï¸ ä¿®å¤å†…å®¹</h3>
        <ul>
            <li>âœ… æ·»åŠ äº†æŒ‡æ•°é€€é¿é‡è¯•æœºåˆ¶ï¼ˆ429é”™è¯¯ï¼‰</li>
            <li>âœ… æ·»åŠ äº†è¯·æ±‚é˜Ÿåˆ—ç®¡ç†ï¼Œé¿å…å¹¶å‘è¯·æ±‚</li>
            <li>âœ… è®¾ç½®äº†æœ€å°è¯·æ±‚é—´éš”ï¼ˆ1ç§’ï¼‰</li>
            <li>âœ… æ”¹è¿›äº†é”™è¯¯åˆ†ç±»å’Œå¤„ç†</li>
            <li>âœ… å¢å¼ºäº†å“åº”æ•°æ®éªŒè¯</li>
        </ul>
    </div>
    
    <div>
        <button class="test-btn" onclick="testSingleRequest()">å•æ¬¡APIè°ƒç”¨æµ‹è¯•</button>
        <button class="test-btn" onclick="testMultipleRequests()">å¤šæ¬¡å¹¶å‘æµ‹è¯•</button>
        <button class="test-btn" onclick="testQueueSystem()">é˜Ÿåˆ—ç³»ç»Ÿæµ‹è¯•</button>
        <button class="test-btn" onclick="testFallbackSystem()">å¤‡ç”¨ç³»ç»Ÿæµ‹è¯•</button>
        <button class="test-btn" onclick="clearResults()">æ¸…ç©ºç»“æœ</button>
    </div>
    
    <div id="progress-container" style="display: none;">
        <div class="progress">
            <div id="progress-bar" class="progress-bar" style="width: 0%;"></div>
        </div>
        <div id="progress-text">å‡†å¤‡ä¸­...</div>
    </div>
    
    <div id="results"></div>
    
    <!-- åŠ è½½è„šæœ¬ -->
    <script src="config/gameConfig.js"></script>
    <script src="config/questionTemplates.js"></script>
    <script src="js/llmIntegration.js"></script>
    
    <script>
        const results = document.getElementById('results');
        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        
        function addResult(title, content, type = 'result') {
            const div = document.createElement('div');
            div.className = type;
            div.innerHTML = `
                <div class="status">${title}</div>
                <pre>${content}</pre>
            `;
            results.appendChild(div);
        }
        
        function clearResults() {
            results.innerHTML = '';
            hideProgress();
        }
        
        function showProgress() {
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';
            progressText.textContent = 'å‡†å¤‡ä¸­...';
        }
        
        function updateProgress(percent, text) {
            progressBar.style.width = percent + '%';
            progressText.textContent = text;
        }
        
        function hideProgress() {
            progressContainer.style.display = 'none';
        }
        
        async function testSingleRequest() {
            addResult('ğŸ”„ å•æ¬¡APIè°ƒç”¨æµ‹è¯•', 'æµ‹è¯•åŸºæœ¬çš„APIè°ƒç”¨å’Œé”™è¯¯å¤„ç†...', 'result');
            
            try {
                const llm = new LLMIntegration();
                const startTime = Date.now();
                
                const question = await llm.generateQuestion('sequence', 'easy', 'å¥¥ç‰¹æ›¼æ‹¯æ•‘åœ°çƒ');
                const endTime = Date.now();
                
                if (question && question.story && question.question) {
                    addResult('âœ… APIè°ƒç”¨æˆåŠŸ', 
                        `è€—æ—¶: ${endTime - startTime}ms\n` +
                        `æ•…äº‹: ${question.story.substring(0, 50)}...\n` +
                        `é¢˜ç›®: ${question.question.substring(0, 50)}...`, 'success');
                } else {
                    addResult('âš ï¸ ä½¿ç”¨å¤‡ç”¨é¢˜ç›®', 
                        `APIå¯èƒ½å¤±è´¥ï¼Œä½¿ç”¨äº†å¤‡ç”¨é¢˜ç›®\n` +
                        `è€—æ—¶: ${endTime - startTime}ms\n` +
                        `æ•…äº‹: ${question.story}`, 'warning');
                }
            } catch (error) {
                addResult('âŒ æµ‹è¯•å¤±è´¥', error.message, 'error');
            }
        }
        
        async function testMultipleRequests() {
            addResult('ğŸš€ å¤šæ¬¡å¹¶å‘æµ‹è¯•', 'åŒæ—¶å‘é€5ä¸ªAPIè¯·æ±‚ï¼Œæµ‹è¯•é˜Ÿåˆ—å’Œé‡è¯•æœºåˆ¶...', 'result');
            showProgress();
            
            const requests = [];
            const llm = new LLMIntegration();
            const startTime = Date.now();
            
            for (let i = 0; i < 5; i++) {
                requests.push(
                    llm.generateQuestion('sequence', 'easy', `æµ‹è¯•ä¸»é¢˜${i+1}`)
                        .then(result => ({ index: i+1, result, success: true }))
                        .catch(error => ({ index: i+1, error: error.message, success: false }))
                );
            }
            
            const results_data = [];
            for (let i = 0; i < requests.length; i++) {
                updateProgress((i / requests.length) * 50, `ç­‰å¾…è¯·æ±‚ ${i+1}/${requests.length}...`);
                const result = await requests[i];
                results_data.push(result);
                updateProgress(50 + (i / requests.length) * 50, `å®Œæˆè¯·æ±‚ ${i+1}/${requests.length}`);
            }
            
            const endTime = Date.now();
            hideProgress();
            
            let successCount = 0;
            let fallbackCount = 0;
            let errorCount = 0;
            
            results_data.forEach(result => {
                if (result.success) {
                    if (result.result && result.result.story && result.result.story.includes('å¥¥ç‰¹æ›¼å‘ç°')) {
                        fallbackCount++;
                    } else {
                        successCount++;
                    }
                } else {
                    errorCount++;
                }
            });
            
            addResult('ğŸ“Š å¹¶å‘æµ‹è¯•ç»“æœ', 
                `æ€»è€—æ—¶: ${endTime - startTime}ms\n` +
                `æˆåŠŸè¯·æ±‚: ${successCount}\n` +
                `å¤‡ç”¨é¢˜ç›®: ${fallbackCount}\n` +
                `é”™è¯¯è¯·æ±‚: ${errorCount}\n` +
                `å¹³å‡è€—æ—¶: ${Math.round((endTime - startTime) / 5)}ms`, 
                successCount > 0 ? 'success' : (fallbackCount > 0 ? 'warning' : 'error'));
        }
        
        async function testQueueSystem() {
            addResult('â³ é˜Ÿåˆ—ç³»ç»Ÿæµ‹è¯•', 'æµ‹è¯•è¯·æ±‚é˜Ÿåˆ—çš„é¡ºåºå¤„ç†å’Œé—´éš”æ§åˆ¶...', 'result');
            
            try {
                const llm = new LLMIntegration();
                const timestamps = [];
                
                // è®°å½•é˜Ÿåˆ—çŠ¶æ€
                const originalProcessQueue = llm.processQueue;
                llm.processQueue = async function() {
                    timestamps.push(Date.now());
                    return originalProcessQueue.call(this);
                };
                
                // å¿«é€Ÿæäº¤3ä¸ªè¯·æ±‚
                const promise1 = llm.generateQuestion('sequence', 'easy', 'é˜Ÿåˆ—æµ‹è¯•1');
                const promise2 = llm.generateQuestion('pattern', 'easy', 'é˜Ÿåˆ—æµ‹è¯•2');
                const promise3 = llm.generateQuestion('comparison', 'easy', 'é˜Ÿåˆ—æµ‹è¯•3');
                
                await Promise.all([promise1, promise2, promise3]);
                
                // åˆ†ææ—¶é—´é—´éš”
                let intervals = '';
                for (let i = 1; i < timestamps.length; i++) {
                    const interval = timestamps[i] - timestamps[i-1];
                    intervals += `è¯·æ±‚${i+1}é—´éš”: ${interval}ms\n`;
                }
                
                addResult('âœ… é˜Ÿåˆ—ç³»ç»Ÿæµ‹è¯•', 
                    `å¤„ç†äº†${timestamps.length}ä¸ªè¯·æ±‚\n${intervals}`, 'success');
                    
            } catch (error) {
                addResult('âŒ é˜Ÿåˆ—æµ‹è¯•å¤±è´¥', error.message, 'error');
            }
        }
        
        async function testFallbackSystem() {
            addResult('ğŸ›¡ï¸ å¤‡ç”¨ç³»ç»Ÿæµ‹è¯•', 'æµ‹è¯•å½“APIå®Œå…¨ä¸å¯ç”¨æ—¶çš„å¤‡ç”¨é¢˜ç›®ç³»ç»Ÿ...', 'result');
            
            try {
                const llm = new LLMIntegration();
                
                // ä¸´æ—¶ç¦ç”¨APIè°ƒç”¨æ¥æµ‹è¯•å¤‡ç”¨ç³»ç»Ÿ
                const originalQueuedAPICall = llm.queuedAPICall;
                llm.queuedAPICall = async function(prompt) {
                    throw new Error('æ¨¡æ‹ŸAPIä¸å¯ç”¨');
                };
                
                const question = await llm.generateQuestion('sequence', 'easy', 'å¤‡ç”¨æµ‹è¯•');
                
                if (question && question.story && question.question) {
                    addResult('âœ… å¤‡ç”¨ç³»ç»Ÿæ­£å¸¸', 
                        `æˆåŠŸç”Ÿæˆå¤‡ç”¨é¢˜ç›®:\n` +
                        `æ•…äº‹: ${question.story}\n` +
                        `é¢˜ç›®: ${question.question}\n` +
                        `é€‰é¡¹: ${question.options.join(', ')}\n` +
                        `ç­”æ¡ˆ: ${question.correctAnswer}`, 'success');
                } else {
                    addResult('âŒ å¤‡ç”¨ç³»ç»Ÿå¤±è´¥', 'å¤‡ç”¨é¢˜ç›®æ ¼å¼ä¸æ­£ç¡®', 'error');
                }
                
                // æ¢å¤åŸå§‹æ–¹æ³•
                llm.queuedAPICall = originalQueuedAPICall;
                
            } catch (error) {
                addResult('âŒ å¤‡ç”¨ç³»ç»Ÿæµ‹è¯•å¤±è´¥', error.message, 'error');
            }
        }
        
        // é¡µé¢åŠ è½½åè‡ªåŠ¨è¿è¡ŒåŸºç¡€æµ‹è¯•
        document.addEventListener('DOMContentLoaded', () => {
            addResult('ğŸ“„ é¡µé¢åŠ è½½å®Œæˆ', 'å¯ä»¥å¼€å§‹æµ‹è¯•APIé‡è¯•æœºåˆ¶...', 'result');
        });
    </script>
</body>
</html>
